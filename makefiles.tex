%%
%%
%% makefiles.tex for  in /doctorat/ece/partenariat/cours/outils_gnu
%%
%% Made by Philippe THIERRY
%% Login   <Philippe THIERRYreseau-libre.net>
%%
%% Started on  Wed Sep  1 18:07:34 2010 Philippe THIERRY
%% Last update mer. 08 sept. 2010 20:21:26 CEST Philippe THIERRY
%%

\chapter{La commande GNU Make}

{\it Il s'agit, dans le cadre de ce chapitre, de décrire comment on automatise la production de
gros logiciels, et quelles sont les problématiques qui en découlent}

\section{Principe des \index{Makefile}Makefiles}

\paragraph{}
Le système de Makefile a été créé dans le but de simplifier la production d'un logiciel. Il
s'articule autour de fichiers de configuration, nommés {\texttt Makefile}, qui définissent les
différents éléments des sources et le traitement qui leur est associé.\\
Ces fichiers de configuration sont traité par le binaire {\texttt make}, qui existe en plusieurs
versions, dont les célèbres BSD Make et GNU Make. Sous Linux, c'est le make de la GNU qui est
installé par défaut. Cette version intègre des capacités supplémentaires par rapport au make de BSD,
ce qui peut parfois rendre les Makefiles non portables si ils utilisent ces fonctionnalités.

\subsection{Les cibles et les dépendances}

\paragraph{}
Dans un fichier Makefile, on appelle {\it cible} (target) un ensemble de traitement réunis sous un
même nom.\\
Cette cible est appellable comme argument de la commande {\texttt make}, impliquant l'exécution de
la cible demandée :
\begin{lstlisting}[caption={Appeler une cible spécifique dans un Makefile},label=lst:call_target]
sh$ make -j 2 ma_cible
\end{lstlisting}

\paragraph{}
Un cible de Makefile se rédige ainsi:
\begin{lstlisting}[language=Make,caption={Rédaction d'une première cible de Makefile},label=lst:mak_target]
ma_cible:
	echo "executing ma_cible"
	cp fichier1 fichier2
	echo "end of execution of ma_cible"
\end{lstlisting}

\paragraph{}
Le nom d'une cible doit être écrite en un seul mot, et doit être impérativement seule avant les
deux points. Il est possible de lui préciser des dépendances après les deux points, comme un
ensemble d'autre cibles qui seront appellées dans l'ordre d'écriture.

\paragraph{}
Tous les traitements exécutés par une cible s'écrivent en commençant par le caractère tabulation,
et doivent se succéder sans ligne blanche ou tout autre ligne ne commençant pas par une
tabulation.\\
Une ligne blanche indique la fin de la cible en cours.

\paragraph{}
Comme dit précédement, une cible peut avoir des dépendances envers d'autres cibles. Cela s'écrit
simplement comme une suite de cibles à droite du deux points:
\begin{lstlisting}[language=Make,caption={Définir des dépendances entres cibles de Makefile},label=lst:mak1]
prepare:
	touch fichier1

get_info:
	cat /proc/cpuinfo > fichier1

ma_cible: prepare get_info
	echo "executing ma_cible"
	cp fichier1 fichier2
	echo "end of execution of ma_cible"
\end{lstlisting}

\paragraph{}
en demandant l'exécution de la cible {\it ma\_cible}, la commande make va successivement exécuter,
dans cette ordre, les cibles {\it prepare}, {\it get\_info}, et {\it ma\_cible}.

\paragraph{}
Comme on le voit dans cette section, le système de Makefile ne sert pas uniquement à automatiser la
compilation. Il est capable d'exécuter n'importe quelle commande.

L'usage d'un Makefile tel que dans le script \ref{lst:mak1} est assez simpliste. Il est en réalité
possible de créer des Makefiles beaucoup plus complexes en s'appuyant complètement sur la grammaire
de make.

\section{Le langage des Makefiles}

\subsection{Les variables}

\paragraph{}
Dans un Makefile, il est possible de définir des variables. La définition d'une variable se fait
par convention avant la définition des règles. Ces dernières peuvent altérer la valeur d'une
variable en fonction du besoin.

\paragraph{}
Une variable de Makefile s'écrit par convention en majuscule. Sa définition peut se faire de trois
manières, comme l'indique le script \ref{lst:makvar}.

\begin{lstlisting}[language=Make,caption={Les variables dans les Makefile},label=lst:makvar]
VAR = foo
VAR ?= foo
VAR += foo
\end{lstlisting}

\paragraph{}
Les trois manières d'assigner une valeur à une variables sont, dans l'ordre d'apparition :
\begin{enumerate}
\item la variable {\it VAR} vaut {\tt foo}
\item la variable {\it VAR} vaut {\tt foo} uniquement si elle n'existe pas déjà. Si cette dernière
est déjà existante dans le contexte d'exécution du Makefile, elle n'est pas modifiée.
\item la variable {\it VAR} voit sa valeur concatènée avec la valeur en argument, un espace
séparant les deux valeurs.
\end{enumerate}

\paragraph{}
Il est possible d'assigner à une variable le résultat d'une ligne de commande. Pour cela, on
encapsule la valeur dans le marqueur {\tt \$()}.

\begin{lstlisting}[caption={Assigner le résultat d'une commande à une variable},label=lst:cmd_var]
DATE = $(date +"%d-%M-%Y")
\end{lstlisting}

\subsection{Les structures de contrôle}

\paragraph{}
Il existe des structure de contrôle dans le langage des Makefiles. Elle permette de faire de ne
prendre en compte qu'une partie du Makefile en fonction de le valeur d'une donnée, ce qui permet
par exemple de faire dépendre un traitement d'un élément extérieur.

\begin{lstlisting}[language=Make,caption=Les structures de contrôles des Makefiles,label=lst:mak_ctrl]
CFLAGS=-W -ggdb

ifeq ($(MORE_CFLAGS),1)
	CFLAGS += -Wall -Wextra -Werror
endif

compile:
	gcc $CFLAGS) my_file.c -o foo

\end{lstlisting}

\paragraph{}
Le script \ref{lst:mak_ctrl} peux donc générer deux appels au compilateur. Un appel classique à
{\tt make compile} exécute la commande suivante :\\
\begin{lstlisting}
gcc -W -ggdb my_file.c -o foo
\end{lstlisting}
à l'inverse, la commande {\tt MORE\_CFLAGS=1 make compile} exécute la commande suivante :
\begin{lstlisting}
gcc -W -ggdb -Wall -Wextra -Werror my_fyle.c -o foo
\end{lstlisting}

\paragraph{}
Dans le cadre du script \ref{lst:mak_ctrl}, c'est l'assignation d'une variable qui est encadrée. Il
est cependant possible d'utiliser les structures de contrôle pour encapsuler des cibles entières,
en fonction du besoin.

\paragraph{}
Il existe d'autres structures de contrôle dans le langage des Makefile. Il s'agit des
déclarations:\\
\begin{itemize}
\item {\tt ifneq-else-endif}, qui se base sur un test faux d'égalité
\item {\tt ifdef-else-endif}, qui se base sur l'existance de l'argument
\item {\tt ifndef-else-endif}, qui se base sur la non-existance de l'argument
\end{itemize}


\subsection{La récursivité}

\paragraph{}
Comme vu précédement, les sources d'un projet contient plusieurs répertoire. Par convention, un
Makefile donné ne traite que du répertoire dans lequel il est présent. Ainsi, on rédige non pas un
seul mais plusieurs Makefiles, avec un seul Makefile dit {\it racine}, se chargeant d'appeller les
autres en fonction du besoin.

\paragraph{}
\begin{lstlisting}[caption=Répartition des Makefiles dans un projet,label=lst:mak_directory]
 [d] doc/
  f     Makefile
  f     mydoc.tex
 [d] src/
  f     Makefile
  f     foo.c
  f AUTHORS
  f ChangeLog
  f Makefile
  f README
\end{lstlisting}

\paragraph{}
Par convention, le Makefile se trouvant à la racine du répertoire est dit Makefile {\it racine}.
C'est lui qui se chargera d'appeller les autres Makefile en fonction du besoin. En effet, le
développeur et plus généralement l'utilisateur du logiciel n'a pas à connaître la décomposition des
sources du logiciel pour le construire. Seul les commandes fournies par le Makefile de la racine
doivent suffirent à compiler l'ensemble. En considérant le réperoire projet
\ref{lst:mak_directory}, le Makefile de la racine serait proche de celui donné dans le script
\ref{lst:root_mak}\\

\begin{lstlisting}[language=Make,caption={Makefile racine type},label=lst:root_mak]
all:
	make -C src all

doc:
	make -C doc all

help:
	echo "make all compile les sources, make doc génère la documentation"
\end{lstlisting}

\paragraph{}
L'option -C de make permet de lui spécifier dans quel répertoire il doit chercher le Makefile. On
constate donc qu'en exécutant la commande {\tt make all} à la racine, cette dernière va, par
récursion, appeller la commande {\tt make all} dans le répertoire src.\\
Il en va de même pour la commande {\tt make doc} qui va appeller la commande {\tt make all}, dans
doc.

\subsection{Construire des éléments communs à tous les Makefile}

\paragraph{}
In arrive qu'un certain nombre d'éléments puissent être redondant parmis les différents Makefiles.
Il peut s'agir de variables ou de cibles. Plutôt que de réécrire ces éléments dans chaque Makefile
avec un risque d'inconcistance, il est possible d'écrire un sous ensemble du Makefile dans un
fichier qui sera intégré dans les différents Makefiles du projet.

\paragraph{}
Par convention, ces makefiles ont une extention de fichier {\tt .mk}. Il n'y a pas de convention
sur leur nom et peuvent être appellé de différentes manières.

\paragraph{}
Afin d'include un (ou plusieurs) de ces fichier dans un Makefile, on utilise la directive {\tt
include}. Le script \ref{lst:mak_include} donne un exemple de ligne d'inclusion.

\begin{lstlisting}{caption={Exemple de fichier .mk : infos.mk}}
PROJECTVERSION=0.12.3
PROJECTNAME=libfoobar
AUTHOR="Dave Null"
\end{lstlisting}

\begin{lstlisting}{language=Make,caption={inclusion d'un fichier mk dans un Makefile},label=lst:mak_include}
include infos.mk

PROJDIR=$(PROJECTNAME)-$(PROJECTVERSION)

init:
	mkdir $(PROJDIR)
	@echo $(AUTHOR) > $(PROJDIR)/Authors

...
\end{lstlisting}


\section{Décomposer et automatiser la compilation}

\paragraph{}
Il a été vu précédement que le système de Makefile fournit une base simple et efficace pour
automatiser des traitements, et ce de toute nature.\\
Cependant, l'élément pour lequel les Makefiles prennent tout leur sens et fournissent le plus de
capacités est l'automatisation de la production. On parle ici bien de production et non simplement
de compilation, qui n'est en réalité qu'un de ses multiples aspects, avec la génération de docs,
l'exécution des campagnes de tests, ou encore l'installation de l'applicatif.

\subsection{La grammaire des Makefiles pour la compilation}

\paragraph{}
De manière générale, pour une règle donnée, il existe deux variables importantes :
\begin{itemize}
\item {\tt \$@} : cette variable contient le nom de la règle courante, et peut donc être utilisée
lors de la rédaction des actions d'une règle.
\item {\tt \$<} : cette variable contient le nom des éléments d'entrée d'une règle. Cette variable
est régulièrement utilisée dans la rédaction des cibles de compilation.
\end{itemize}

\paragraph{}
Un autre élément très utile des Makefile et l'aspect traitement de chaine de caractère lors de la
définition d'une variable, dont la syntaxe est ressemblante à celle du {\it bash}.\\
Ainsi, on peut, à partir d'une variable ayant une chaîne de caractère donnée, la modifier comme on
le souhaite pour définir d'autres variables. Un exemple étant toujours mieux qu'un long discrours,
voici un exemple d'emploi permettant, pour une chaîne donnée, de remplacer une sous-chaîne par une
autre :\\
\begin{lstlisting}{language=Make,caption={Traitement de chaînes de caractères dans les Makefiles},label=lst:mak_glob}
SOURCE = main.c
OBJ = $(SOURCE:.c=.o) # ici, OBJ vaut main.o
ASM = $(SOURCE:.c=.s) # ici ASM vaut main.s
\end{lstlisting}

L'intérêt principale et de définir la chaîne à un seul endroit, pour en dériver sa valeur ensuite.
Cela permet d'éviter une inconsistance en définissant plusieurs fois la chaîne complète.

\subsection{Les subtilités des nom de cibles}

\paragraph{}
Il est tout à fait possible d'utiliser une variable comme nom de cible. C'est d'ailleurs souvent le cas
comme le montre le script \ref{lst:mak_all}.

\paragraph{}
Il existe de plus des noms de cibles spécifiques. Il en existe un particulier pour la compilation.
Afin d'en comprendre le sens, voici son usage:
\begin{lstlisting}
.c.o :
	$(CC) $(CFLAGS) -c $<
\end{lstlisting}
Cette cible est faite pour la compilation des fichiers sources en fichiers objets. Cette règle
prend en entrée les fichiers se terminant par l'extension {\tt .c} définis plus haut dans le
makefile et les intègre à la variable {\tt \$<} pour pouvoir être utilisés.\\
Dans le script \ref{lst:mak_all}, cette règle est utiliser pour générer les fichiers objets à
partir des sources. L'ensemble des fichiers sources sont intégrés à la variable {\tt \$<} qui est
utilisée dans la règle écrite pour cette cible.

\subsection{Les règles PHONY}
\index{Makefile!PHONY}

\paragraph{}
Il arrive parfois qu'un fichier ou un dossier du répertoire courant porte le même nom qu'une cible.
C'est en général le cas de {\it doc}.\\
Le problème est que le système de Makefile considère que si le nom d'une cible porte le nom d'un
fichier ou d'un répertoire, ce dernier est la conséquence de la cible elle même. En conséquence, si
ce dernier est préexistant lors de l'appel à cette cible et que cette dernière ne possède pas de
dépendance, alors elle ne sera pas exécutée.\\
Dans l'exemple d'une cible {\tt doc}, où le répertoire doc est déjà présent dans le répertoire
courant, on a le comportement suivant:
\begin{lstlisting}
sh$ make doc
target 'doc' already up to date.
sh$
\end{lstlisting}
Afin de forcer l'exécution de la cible même si le fichier/dossier est prééxistant, on utilise la
cible spéciale {\it .PHONY}. Cette cible force l'exécution des cibles dont elle dépend. Il y en a
un exemple dans le script \ref{lst:mak_all}

\subsection{Un Makefile complet pour la compilation}

\paragraph{}
\begin{lstlisting}{language=Make,caption={Exemple de Makefile complet pour la compilation},label=lst:mak_all}
#############################################################################
## basic macros
#############################################################################
CC          ?= gcc
AR	     = ar
CFLAGS      ?= -Wall -W -Werror -Wextra -ansi -pedantic
LD           = ld
LDFLAGS	     = 
ARFLAGS	     = cr
RM	     = rm
RMFLAGS      = -rf
TAR          = tar
TARFLAGS     = -cjvf
MAKE        ?= make
INSTALL      = install
CTAGS        = ctags -x > tags
DEPEND       = makedepend $(CFLAGS)
MAKE         = make

#############################################################################
## lint -- static code mistakes detector
#############################################################################
LINT         = splint
LARCH_PATH   = /usr/local/lib
LCLIMPORTDIR = /usr/local/share/splint/imports

#############################################################################
## dist target file
#############################################################################
DISTTARGET   = .tar.bz2

#############################################################################
## project's source and generated files
#############################################################################
TARGET	     = foobar
SOURCE	     =	main.c \
		foo.c \
		bar.c \
		baz.c

OBJS	     = $(SOURCE:.c=.o)
HEADERS      = $(SOURCE:.c=.h)
TODEL	     = tags *~ .*.swp

#############################################################################
## rules
#############################################################################

all : $(TARGET)

$(TARGET) : $(OBJS)
	$(CC) -o $@ $(OBJS) $(LDFLAGS)

.c.o :
	$(CC) $(CFLAGS) -c $<

doc :
	$(MAKE) -C doc all

lint :
	$(LINT) $(CFLAGS) $(SOURCE)

tags : $(SOURCE)
	$(CTAGS) $(SOURCE)

depend : $(SOURCE)
	$(DEPEND) $(SOURCE)

.PHONY: clean doc

clean : 
	$(RM) $(RMFLAGS) $(OBJS) $(TODEL)

distclean : clean
	$(RM) $(RMFLAGS) $(TARGET)

dist : distclean
	$(TAR) $(TARFLAGS) $(DISTTARGET) .

check : $(TARGET)
	cd check; $(MAKE) all

install : $(TARGET)
	@echo you must be root to install
\end{lstlisting}

\section{Les limitations}

\section{Ce qu'il ne faut pas faire}
