%%
%%
%% makefiles.tex for  in /doctorat/ece/partenariat/cours/outils_gnu
%%
%% Made by Philippe THIERRY
%% Login   <Philippe THIERRYreseau-libre.net>
%%
%% Started on  Wed Sep  1 18:07:34 2010 Philippe THIERRY
%% Last update dim. 12 sept. 2010 11:44:36 CEST Philippe THIERRY
%%

\chapter{La commande GNU Make}

% style for Makefile
\lstset{
morecomment=[l][\color{blue}]{\#},
morekeywords={include,ifeq,ifneq,ifndef,ifdef,else,endif,.c.o}
%morecomment=[s][\color{green}]{\$(}{)},
emph={[2].PHONY},emphstyle={[2]\color{red}}
}



{\it Il s'agit, dans le cadre de ce chapitre, de décrire comment on automatise la production de
gros logiciels, et quelles sont les problématiques qui en découlent}

\section{Principe des \index{Makefile}Makefiles}

\paragraph{}
Le système de Makefile a été créé dans le but de simplifier la production d'un logiciel. Il
s'articule autour de fichiers de configuration, nommés {\tt Makefile}, qui définissent les
différents éléments des sources et le traitement qui leur est associé.\\
Ces fichiers de configuration sont traités par le binaire {\tt make}, qui existe en plusieurs
versions, dont les célèbres BSD Make et GNU Make. Sous Linux, c'est le make de la GNU qui est
installé par défaut. Cette version intègre des capacités supplémentaires par rapport au make de BSD,
ce qui peut parfois rendre les Makefiles non portables s'ils utilisent ces fonctionnalités.

\subsection{Les cibles et les dépendances}

\paragraph{}
Dans un fichier Makefile, on appelle {\it cible} (target) un ensemble de traitements réunis sous un
même nom.\\
Cette cible est appellable comme argument de la commande {\tt make}, impliquant l'exécution de
la cible demandée :
\begin{lstlisting}[caption={Appeler une cible spécifique dans un Makefile},label=lst:call_target]
sh$ make -j 2 ma_cible
\end{lstlisting}

\paragraph{}
Un cible de Makefile se rédige ainsi:
\begin{lstlisting}[caption={Rédaction d'une première cible de Makefile},label=lst:mak_target]
ma_cible:
	echo "executing ma_cible"
	cp fichier1 fichier2
	echo "end of execution of ma_cible"
\end{lstlisting}

\paragraph{}
Le nom d'une cible doit être écrit en un seul mot, et doit être impérativement seul avant les
deux points. Il est possible de lui préciser des dépendances après les deux points, comme un
ensemble d'autres cibles qui seront appellées dans l'ordre d'écriture.

\paragraph{}
Tous les traitements exécutés par une cible s'écrivent en commençant par le caractère tabulation,
et doivent se succéder sans ligne blanche ou tout autre ligne ne commençant pas par une
tabulation.\\
Une ligne blanche indique la fin de la cible en cours.

\paragraph{}
Comme dit précédemment, une cible peut avoir des dépendances envers d'autres cibles. Cela s'écrit
simplement comme une suite de cibles à droite des deux points:
\begin{lstlisting}[caption={Définir des dépendances entres cibles de Makefile},label=lst:mak1]
prepare:
	touch fichier1

get_info:
	cat /proc/cpuinfo > fichier1

ma_cible: prepare get_info
	echo "executing ma_cible"
	cp fichier1 fichier2
	echo "end of execution of ma_cible"
\end{lstlisting}

\paragraph{}
En demandant l'exécution de la cible {\it ma\_cible}, la commande make va successivement exécuter,
dans cet ordre, les cibles {\it prepare}, {\it get\_info}, et {\it ma\_cible}.

\paragraph{}
Comme on le voit dans cette section, le système de Makefile ne sert pas uniquement à automatiser la
compilation. Il est capable d'exécuter n'importe quelle commande.

L'usage d'un Makefile tel que dans le script \ref{lst:mak1} est assez simpliste. Il est en réalité
possible de créer des Makefiles beaucoup plus complexes en s'appuyant complètement sur la grammaire
de make.

\section{Le langage des Makefiles}

\subsection{Les variables}

\paragraph{}
Dans un Makefile, il est possible de définir des variables. La définition d'une variable se fait
par convention avant la définition des règles. Ces dernières peuvent altérer la valeur d'une
variable en fonction du besoin.

\paragraph{}
Une variable de Makefile s'écrit par convention en majuscule. Sa définition peut se faire de trois
manières, comme l'indique le script \ref{lst:makvar}.

\begin{lstlisting}[caption={Les variables dans les Makefiles},label=lst:makvar]
VAR = foo
VAR ?= foo
VAR += foo
\end{lstlisting}

\paragraph{}
Les trois manières d'assigner une valeur à une variable sont, dans l'ordre d'apparition :
\begin{enumerate}
\item la variable {\it VAR} vaut {\tt foo}
\item la variable {\it VAR} vaut {\tt foo} uniquement si elle n'existe pas déjà. Si cette dernière
est déjà existante dans le contexte d'exécution du Makefile, elle n'est pas modifiée.
\item la variable {\it VAR} voit sa valeur concaténée avec la valeur en argument, un espace
séparant les deux valeurs.
\end{enumerate}

\paragraph{}
Il est possible d'assigner à une variable le résultat d'une ligne de commande. Pour cela, on
encapsule la valeur dans le marqueur {\tt \$()}.

\begin{lstlisting}[caption={Assigner le résultat d'une commande à une variable},label=lst:cmd_var]
DATE = $(date +"%d-%M-%Y")
\end{lstlisting}

\subsection{Les structures de contrôle}

\paragraph{}
Il existe des structures de contrôle dans le langage des Makefiles. Elles permettent de ne
faire prendre en compte, par l'outil {\tt make}, qu'une partie du Makefile en fonction de la valeur
d'une donnée. Cela permet, par exemple, de faire dépendre un traitement d'un élément extérieur.

\begin{lstlisting}[caption=Les structures de contrôles des Makefiles,label=lst:mak_ctrl]
CFLAGS=-W -ggdb

ifeq ($(MORE_CFLAGS),1)
	CFLAGS += -Wall -Wextra -Werror
endif

compile:
	gcc $CFLAGS) my_file.c -o foo

\end{lstlisting}

\paragraph{}
Le script \ref{lst:mak_ctrl} peut donc générer deux appels au compilateur. Un appel classique à
{\tt make compile} exécute la commande suivante :\\
\begin{lstlisting}
gcc -W -ggdb my_file.c -o foo
\end{lstlisting}
à l'inverse, la commande {\tt MORE\_CFLAGS=1 make compile} exécute la commande suivante :
\begin{lstlisting}
gcc -W -ggdb -Wall -Wextra -Werror my_fyle.c -o foo
\end{lstlisting}

\paragraph{}
Dans le cadre du script \ref{lst:mak_ctrl}, c'est l'assignation d'une variable qui est encadrée. Il
est cependant possible d'utiliser les structures de contrôle pour encapsuler des cibles entières,
en fonction du besoin.

\paragraph{}
Il existe d'autres structures de contrôle dans le langage des Makefiles. Il s'agit des
déclarations:\\
\begin{itemize}
\item {\tt ifneq-else-endif}, qui se base sur un test faux d'égalité
\item {\tt ifdef-else-endif}, qui se base sur l'existance de l'argument
\item {\tt ifndef-else-endif}, qui se base sur la non-existance de l'argument
\end{itemize}


\subsection{La récursivité}

\paragraph{}
Comme vu précédemment, les sources d'un projet contiennent plusieurs répertoires. Par convention, un
Makefile donné ne traite que du répertoire dans lequel il est présent. Ainsi, on rédige non pas un
seul mais plusieurs Makefiles, avec un seul Makefile dit {\it racine}, se chargeant d'appeller les
autres en fonction du besoin.

\paragraph{}
\begin{lstlisting}[caption=Répartition des Makefiles dans un projet,label=lst:mak_directory]
 [d] doc/
  f     Makefile
  f     mydoc.tex
 [d] src/
  f     Makefile
  f     foo.c
  f AUTHORS
  f ChangeLog
  f Makefile
  f README
\end{lstlisting}

\paragraph{}
Par convention, le Makefile se trouvant à la racine du répertoire est dit Makefile {\it racine}.
C'est lui qui se chargera d'appeller les autres Makefiles en fonction du besoin. En effet, le
développeur, et plus généralement l'utilisateur du logiciel, n'a pas à connaître la décomposition des
sources du logiciel pour le construire. Seules les commandes fournies par le Makefile de la racine
doivent suffire à compiler l'ensemble. En considérant le réperoire projet
\ref{lst:mak_directory}, le Makefile de la racine serait proche de celui donné dans le script
\ref{lst:root_mak}\\

\begin{lstlisting}[caption={Makefile racine type},label=lst:root_mak]
all:
	make -C src all

doc:
	make -C doc all

help:
	echo "make all compile les sources, make doc génère la documentation"
\end{lstlisting}

\paragraph{}
L'option -C de make permet de lui spécifier dans quel répertoire il doit chercher le Makefile. On
constate donc qu'en exécutant la commande {\tt make all} à la racine, cette dernière va, par
récursion, appeller la commande {\tt make all} dans le répertoire src.\\
Il en va de même pour la commande {\tt make doc} qui va appeller la commande {\tt make all}, dans
doc.

\subsection{Construire des éléments communs à tous les Makefile}

\paragraph{}
Il arrive qu'un certain nombre d'éléments puissent être redondants parmis les différents Makefiles.
Il peut s'agir de variables ou de cibles. Plutôt que de réécrire ces éléments dans chaque Makefile
avec un risque d'inconcistance, il est possible d'écrire un sous-ensemble du Makefile dans un
fichier qui sera intégré dans les différents Makefiles du projet.

\paragraph{}
Par convention, ces Makefiles ont une extention de fichier {\tt .mk}. Il n'y a pas de convention
sur leur nom et peuvent être appellés de différentes manières.

\paragraph{}
Afin d'inclure un (ou plusieurs) de ces fichiers dans un Makefile, on utilise la directive {\tt
include}.
Le script \ref{lst:mak_mk} est un exemple de fichier {\tt .mk}.

\begin{lstlisting}[caption={Exemple de fichier .mk : infos.mk},label=lst:mak_mk]
PROJECTVERSION=0.12.3
PROJECTNAME=libfoobar
AUTHOR="Dave Null"
\end{lstlisting}

Le script \ref{lst:mak_include} donne un exemple de ligne d'inclusion d'un tel fichier.

\begin{lstlisting}[caption={Inclusion d'un fichier mk dans un Makefile},label=lst:mak_include]
include infos.mk

PROJDIR=$(PROJECTNAME)-$(PROJECTVERSION)

init:
	mkdir $(PROJDIR)
	@echo $(AUTHOR) > $(PROJDIR)/Authors

...
\end{lstlisting}


\section{Décomposer et automatiser la compilation}

\paragraph{}
Il a été vu précédement que le système de Makefile fournit une base simple et efficace pour
automatiser des traitements, et ce de toute nature.\\
Cependant, l'élément pour lequel les Makefiles prennent tout leur sens et fournissent le plus de
capacités est l'automatisation de la production. On parle bien ici de production et non simplement
de compilation, qui n'est en réalité qu'un de ses multiples aspects, avec la génération de docs,
l'exécution des campagnes de tests, ou encore l'installation de l'applicatif.

\subsection{La grammaire des Makefiles pour la compilation}

\paragraph{}
De manière générale, pour une règle donnée, il existe deux variables importantes :
\begin{itemize}
\item {\tt \$@} : cette variable contient le nom de la règle courante, et peut donc être utilisée
lors de la rédaction des actions d'une règle.
\item {\tt \$<} : cette variable contient le nom des éléments d'entrée d'une règle. Cette variable
est régulièrement utilisée dans la rédaction des cibles de compilation.
\end{itemize}

\paragraph{}
Un autre élément très utile des Makefiles est l'aspect traitement de chaîne de caractère lors de la
définition d'une variable, dont la syntaxe est ressemblante à celle du {\it bash}.\\
Ainsi, on peut, à partir d'une variable ayant une chaîne de caractère donnée, la modifier comme on
le souhaite pour définir d'autres variables. Un exemple étant toujours mieux qu'un long discours,
voici un exemple d'emploi permettant, pour une chaîne donnée, de remplacer une sous-chaîne par une
autre :\\
\begin{lstlisting}[caption={Traitement de chaînes de caractères dans les Makefiles},label=lst:mak_glob]
SOURCE = main.c
OBJ = $(SOURCE:.c=.o) # ici, OBJ vaut main.o
ASM = $(SOURCE:.c=.s) # ici ASM vaut main.s
\end{lstlisting}

L'intérêt principal est de définir la chaîne à un seul endroit, pour en dériver sa valeur ensuite.
Cela permet d'éviter une inconsistance en définissant plusieurs fois la chaîne complète.

\subsection{Les variables de compilation}

\paragraph{}
Il existe un certain nombre de variables régulièrement utilisées pour rédiger un Makefile pour la
compilation. Ces dernières sont celles employées par les outils de configuration des sources. Sont
décrites ici les variables associées à des projets écrits en C ou en C++.

\begin{itemize}
\item CFLAGS : définit les options de compilation pour un programme en C
\item CXXFLAGS : définit les options de compilation pour un programme en C++
\item LDFLAGS : définit les options de linkage pour un programme en C ou C++
\item TARGET : définit le nom du binaire produit par les sources
\item SOURCES : liste les fichiers sources du projet
\item OBJECTS : liste les fichiers objets du projet
\item HEADERS : liste les en-têtes du projet
\item CC : le compilateur C, en chemin relatif ou absolu
\item CXX : le compilateur C++, en chemin relatif ou absolu
\item LD : le linker, en chemin relatif ou absolu
\item AS : l'assembleur, en chemin relatif ou absolu
\end{itemize}

\paragraph{}
Il existe d'autres variables, mais les principales sont définies ici. On en retrouve une liste plus
grande dans le script \ref{lst:mak_all}.

\subsection{Les subtilités des nom de cibles}

\paragraph{}
Il est tout à fait possible d'utiliser une variable comme nom de cible. C'est d'ailleurs souvent le cas
comme le montre le script \ref{lst:mak_all}.

\paragraph{}
Il existe de plus des noms de cibles spécifiques. Il en existe un particulier pour la compilation.
Afin d'en comprendre le sens, voici son usage:
\begin{lstlisting}
.c.o :
	$(CC) $(CFLAGS) -c $<
\end{lstlisting}
Cette cible est faite pour la compilation des fichiers sources en fichiers objets. Cette règle
prend en entrée les fichiers se terminant par l'extension {\tt .c} définis plus haut dans le
Makefile et les intègre à la variable {\tt \$<} pour pouvoir être utilisés.\\
Dans le script \ref{lst:mak_all}, cette règle est utilisée pour générer les fichiers objets à
partir des sources. L'ensemble des fichiers sources sont intégrés à la variable {\tt \$<} qui est
utilisée dans la règle écrite pour cette cible.

\subsection{Les règles PHONY}
\index{Makefile!PHONY}

\paragraph{}
Il arrive parfois qu'un fichier ou un dossier du répertoire courant porte le même nom qu'une cible.
C'est en général le cas de {\it doc}.\\
Le problème est que le système de Makefile considère que si le nom d'une cible porte le nom d'un
fichier ou d'un répertoire, ce dernier est la conséquence de la cible elle-même. En conséquence, si
ce dernier est préexistant lors de l'appel à cette cible et que cette dernière ne possède pas de
dépendance, alors elle ne sera pas exécutée.\\
Dans l'exemple d'une cible {\tt doc}, où le répertoire doc est déjà présent dans le répertoire
courant, on a le comportement suivant:
\begin{lstlisting}
sh$ make doc
target 'doc' already up to date.
sh$
\end{lstlisting}
Afin de forcer l'exécution de la cible même si le fichier/dossier est prééxistant, on utilise la
cible spéciale {\it .PHONY}. Cette cible force l'exécution des cibles dont elle dépend. Il y en a
un exemple dans le script \ref{lst:mak_all}.

\subsection{Un Makefile complet pour la compilation}

\paragraph{}

\begin{lstlisting}[caption={Exemple de Makefile complet pour la compilation},label=lst:mak_all]
#############################################################################
## basic macros
#############################################################################
CC          ?= gcc
AR	     = ar
CFLAGS      ?= -Wall -W -Werror -Wextra -ansi -pedantic
LD           = ld
LDFLAGS	     = 
ARFLAGS	     = cr
RM	     = rm
RMFLAGS      = -rf
TAR          = tar
TARFLAGS     = -cjvf
MAKE        ?= make
INSTALL      = install
CTAGS        = ctags -x > tags
DEPEND       = makedepend $(CFLAGS)
MAKE         = make

#############################################################################
## lint -- static code mistakes detector
#############################################################################
LINT         = splint
LARCH_PATH   = /usr/local/lib
LCLIMPORTDIR = /usr/local/share/splint/imports

#############################################################################
## dist target file
#############################################################################
DISTTARGET   = .tar.bz2

#############################################################################
## project's source and generated files
#############################################################################
TARGET	     = foobar
SOURCE	     =	main.c \
		foo.c \
		bar.c \
		baz.c

OBJS	     = $(SOURCE:.c=.o)
HEADERS      = $(SOURCE:.c=.h)
TODEL	     = tags *~ .*.swp

#############################################################################
## rules
#############################################################################

all : $(TARGET)

$(TARGET) : $(OBJS)
	$(CC) -o $@ $(OBJS) $(LDFLAGS)

.c.o :
	$(CC) $(CFLAGS) -c $<

doc :
	$(MAKE) -C doc all

lint :
	$(LINT) $(CFLAGS) $(SOURCE)

tags : $(SOURCE)
	$(CTAGS) $(SOURCE)

depend : $(SOURCE)
	$(DEPEND) $(SOURCE)

.PHONY : clean doc

clean : 
	$(RM) $(RMFLAGS) $(OBJS) $(TODEL)

distclean : clean
	$(RM) $(RMFLAGS) $(TARGET)

dist : distclean
	$(TAR) $(TARFLAGS) $(DISTTARGET) .

check : $(TARGET)
	cd check; $(MAKE) all

install : $(TARGET)
	@echo you must be root to install
\end{lstlisting}

\section{Les limitations}

\paragraph{}
Le système de Makefile possède un certain nombre de limitations et de problématiques. En premier
lieu, il ne permet pas, de manière aisée, de vérifier les capacités de la chaîne de compilation.
Ainsi, lorsque l'on définit certaines variables comme CFLAGS, on prend comme hypothèse que la
chaîne de compilation les reconnaît.\\
Cependant, en faisant ainsi, on se heurte parfois à des problèmes de portabilité. En effet, il
arrive fréquemment que le projet soit compilé avec une chaîne de compilation dont on ne maîtrise pas
les versions du compilateur ou encore du linker. Ainsi, selon la version utilisée, les options de
compilation définies dans le Makefile peuvent ne pas être reconnues, et provoquer un arrêt de la
construction du projet.\\
Il en va de même pour la vérification de la présence des divers binaires nécessaires à la
production. Il est possible de définir des fonctions de vérification dans le Makefile, mais elles
sont à écrire par l'utilisateur et peuvent être nombreuses. C'est pour cette raison qu'on utilise
souvent, en complément du système de Makefiles, un système de configuration, comme les {\it
autotools}\index{autotools} ou encore {\it CMake}\index{CMake}.\\
Les autotools étant le plus fréquemment utilisés (ils sont à l'origine de la commande {\tt
configure} que l'on exécute régulièrement lors de l'installation d'un applicatif à partir de ses
sources) car plus anciens. Ce document s'intéresse dans le chapitre suivant à leur fonctionnement
général.
