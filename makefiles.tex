%%
%%
%% makefiles.tex for  in /doctorat/ece/partenariat/cours/outils_gnu
%%
%% Made by Philippe THIERRY
%% Login   <Philippe THIERRYreseau-libre.net>
%%
%% Started on  Wed Sep  1 18:07:34 2010 Philippe THIERRY
%% Last update mar. 07 sept. 2010 22:13:26 CEST Philippe THIERRY
%%

\chapter{La commande GNU Make}

{\it Il s'agit, dans le cadre de ce chapitre, de décrire comment on automatise la production de
gros logiciels, et quelles sont les problématiques qui en découlent}

\section{Principe des \index{Makefile}Makefiles}

\paragraph{}
Le système de Makefile a été créé dans le but de simplifier la production d'un logiciel. Il
s'articule autour de fichiers de configuration, nommés {\texttt Makefile}, qui définissent les
différents éléments des sources et le traitement qui leur est associé.\\
Ces fichiers de configuration sont traité par le binaire {\texttt make}, qui existe en plusieurs
versions, dont les célèbres BSD Make et GNU Make. Sous Linux, c'est le make de la GNU qui est
installé par défaut. Cette version intègre des capacités supplémentaires par rapport au make de BSD,
ce qui peut parfois rendre les Makefiles non portables si ils utilisent ces fonctionnalités.

\subsection{Les cibles et les dépendances}

\paragraph{}
Dans un fichier Makefile, on appelle {\it cible} (target) un ensemble de traitement réunis sous un
même nom.\\
Cette cible est appellable comme argument de la commande {\texttt make}, impliquant l'exécution de
la cible demandée :
\begin{lstlisting}[caption={Appeler une cible spécifique dans un Makefile},label=lst:call_target]
sh$ make -j 2 ma_cible
\end{lstlisting}

\paragraph{}
Un cible de Makefile se rédige ainsi:
\begin{lstlisting}[language=Make,caption={Rédaction d'une première cible de Makefile},label=lst:mak_target]
ma_cible:
	echo "executing ma_cible"
	cp fichier1 fichier2
	echo "end of execution of ma_cible"
\end{lstlisting}

\paragraph{}
Le nom d'une cible doit être écrite en un seul mot, et doit être impérativement seule avant les
deux points. Il est possible de lui préciser des dépendances après les deux points, comme un
ensemble d'autre cibles qui seront appellées dans l'ordre d'écriture.

\paragraph{}
Tous les traitements exécutés par une cible s'écrivent en commençant par le caractère tabulation,
et doivent se succéder sans ligne blanche ou tout autre ligne ne commençant pas par une
tabulation.\\
Une ligne blanche indique la fin de la cible en cours.

\paragraph{}
Comme dit précédement, une cible peut avoir des dépendances envers d'autres cibles. Cela s'écrit
simplement comme une suite de cibles à droite du deux points:
\begin{lstlisting}[language=Make,caption={Définir des dépendances entres cibles de Makefile},label=lst:mak1]
prepare:
	touch fichier1

get_info:
	cat /proc/cpuinfo > fichier1

ma_cible: prepare get_info
	echo "executing ma_cible"
	cp fichier1 fichier2
	echo "end of execution of ma_cible"
\end{lstlisting}

\paragraph{}
en demandant l'exécution de la cible {\it ma\_cible}, la commande make va successivement exécuter,
dans cette ordre, les cibles {\it prepare}, {\it get\_info}, et {\it ma\_cible}.

\paragraph{}
Comme on le voit dans cette section, le système de Makefile ne sert pas uniquement à automatiser la
compilation. Il est capable d'exécuter n'importe quelle commande.

L'usage d'un Makefile tel que dans le script \ref{lst:mak1} est assez simpliste. Il est en réalité
possible de créer des Makefiles beaucoup plus complexes en s'appuyant complètement sur la grammaire
de make.

\section{Le langage des Makefiles}

\subsection{Les variables}

\paragraph{}
Dans un Makefile, il est possible de définir des variables. La définition d'une variable se fait
par convention avant la définition des règles. Ces dernières peuvent altérer la valeur d'une
variable en fonction du besoin.

\paragraph{}
Une variable de Makefile s'écrit par convention en majuscule. Sa définition peut se faire de trois
manières, comme l'indique le script \ref{lst:makvar}.

\begin{lstlisting}[language=Make,caption={Les variables dans les Makefile},label=lst:makvar]
VAR = foo
VAR ?= foo
VAR += foo
\end{lstlisting}

\paragraph{}
Les trois manières d'assigner une valeur à une variables sont, dans l'ordre d'apparition :
\begin{enumerate}
\item la variable {\it VAR} vaut {\tt foo}
\item la variable {\it VAR} vaut {\tt foo} uniquement si elle n'existe pas déjà. Si cette dernière
est déjà existante dans le contexte d'exécution du Makefile, elle n'est pas modifiée.
\item la variable {\it VAR} voit sa valeur concatènée avec la valeur en argument, un espace
séparant les deux valeurs.
\end{enumerate}

\paragraph{}
Il est possible d'assigner à une variable le résultat d'une ligne de commande. Pour cela, on
encapsule la valeur dans le marqueur {\tt \$()}.

\begin{lstlisting}[caption={Assigner le résultat d'une commande à une variable},label=lst:cmd_var]
DATE = $(date +"%d-%M-%Y")
\end{lstlisting}

\subsection{Les structures de contrôle}

\paragraph{}
Il existe des structure de contrôle dans le langage des Makefiles. Elle permette de faire de ne
prendre en compte qu'une partie du Makefile en fonction de le valeur d'une donnée, ce qui permet
par exemple de faire dépendre un traitement d'un élément extérieur.

\begin{lstlisting}[language=Make,caption=Les structures de contrôles des Makefiles,label=lst:mak_ctrl]
CFLAGS=-W -ggdb

ifeq ($(MORE_CFLAGS),1)
	CFLAGS += -Wall -Wextra -Werror
endif

compile:
	gcc $CFLAGS) my_file.c -o foo

\end{lstlisting}

\paragraph{}
Le script \ref{lst:mak_ctrl} peux donc générer deux appels au compilateur. Un appel classique à
{\tt make compile} exécute la commande suivante :\\
\begin{lstlisting}
gcc -W -ggdb my_file.c -o foo
\end{lstlisting}
à l'inverse, la commande {\tt MORE\_CFLAGS=1 make compile} exécute la commande suivante :
\begin{lstlisting}
gcc -W -ggdb -Wall -Wextra -Werror my_fyle.c -o foo
\end{lstlisting}

\paragraph{}
Dans le cadre du script \ref{lst:mak_ctrl}, c'est l'assignation d'une variable qui est encadrée. Il
est cependant possible d'utiliser les structures de contrôle pour encapsuler des cibles entières,
en fonction du besoin.

\paragraph{}
Il existe d'autres structures de contrôle dans le langage des Makefile. Il s'agit des
déclarations:\\
\begin{itemize}
\item {\tt ifneq-else-endif}, qui se base sur un test faux d'égalité
\item {\tt ifdef-else-endif}, qui se base sur l'existance de l'argument
\item {\tt ifndef-else-endif}, qui se base sur la non-existance de l'argument
\end{itemize}


\subsection{La récursivité}

\paragraph{}
Comme vu précédement, les sources d'un projet contient plusieurs répertoire. Par convention, un
Makefile donné ne traite que du répertoire dans lequel il est présent. Ainsi, on rédige non pas un
seul mais plusieurs Makefiles, avec un seul Makefile dit {\it racine}, se chargeant d'appeller les
autres en fonction du besoin.

\paragraph{}
\begin{lstlisting}[caption=Répartition des Makefiles dans un projet,label=lst:mak_directory]
 [f] Makefile
 [d] doc/
 [f]    Makefile
 [f]    mydoc.tex
 [d] src/
 [f]    Makefile
 [f]    foo.c
\end{lstlisting}

\paragraph{}
Par convention, le Makefile se trouvant à la racine du répertoire est dit Makefile {\it racine}.
C'est lui qui se chargera d'appeller les autres Makefile en fonction du besoin. En effet, le
développeur et plus généralement l'utilisateur du logiciel n'a pas à connaître la décomposition des
sources du logiciel pour le construire. Seul les commandes fournies par le Makefile de la racine
doivent suffirent à compiler l'ensemble. En considérant le réperoire projet
\ref{lst:mak_directory}, le Makefile de la racine serait proche de celui donné dans le script
\ref{lst:root_mak}\\

\begin{lstlisting}[language=Make,caption={Makefile racine type},label=lst:root_mak]
all:
	make -C src all

doc:
	make -C doc all

help:
	echo "make all compile les sources, make doc génère la documentation"
\end{lstlisting}

\paragraph{}
L'option -C de make permet de lui spécifier dans quel répertoire il doit chercher le Makefile. On
constate donc qu'en exécutant la commande {\tt make all} à la racine, cette dernière va, par
récursion, appeller la commande {\tt make all} dans le répertoire src.\\
Il en va de même pour la commande {\tt make doc} qui va appeller la commande {\tt make all}, dans
doc.

\subsection{Construire des éléments communs à tous les Makefile}

\paragraph{}
In arrive qu'un certain nombre d'éléments puissent être redondant parmis les différents Makefiles.
Il peut s'agir de variables ou de cibles. Plutôt que de réécrire ces éléments dans chaque Makefile
avec un risque d'inconcistance, il est possible d'écrire un sous ensemble du Makefile dans un
fichier qui sera intégré dans les différents Makefiles du projet.

\paragraph{}
Par convention, ces makefiles ont une extention de fichier {\tt .mk}. Il n'y a pas de convention
sur leur nom et peuvent être appellé de différentes manières.

\paragraph{}
Afin d'include un (ou plusieurs) de ces fichier dans un Makefile, on utilise la directive {\tt
include}. Le script \ref{lst:mak_include} donne un exemple de ligne d'inclusion.

\begin{lstlisting}{caption={Exemple de fichier .mk : infos.mk}}
PROJECTVERSION=0.12.3
PROJECTNAME=libfoobar
AUTHOR="Dave Null"
\end{lstlisting}

\begin{lstlisting}{language=Make,caption={inclusion d'un fichier mk dans un Makefile},label=lst:mak_include}
include infos.mk

PROJDIR=$(PROJECTNAME)-$(PROJECTVERSION)

init:
	mkdir $(PROJDIR)
	@echo $(AUTHOR) > $(PROJDIR)/Authors

...
\end{lstlisting}


\section{Décomposer et automatiser la compilation}

\subsection{La grammaire des Makefiles pour la compilation}

\paragraph{}
Les cibles spéciales

\paragraph{}
Les variables de cibles (fichiers de sortie, fichiers d'entrée)

\subsection{Les subtilités des nom de cibles}

\subsection{Les règles PHONY}
\index{Makefile!PHONY}

\paragraph{}

\subsection{Un Makefile complet pour la compilation}

\begin{lstlisting}{language=Make,caption={Exemple de Makefile complet pour la compilation},label=lst:mak_all}
#############################################################################
## basic macros
#############################################################################
CC          ?= gcc
AR	     = ar
CFLAGS      ?= -Wall -W -Werror -Wextra -ansi -pedantic
LD           = ld
LDFLAGS	     = 
ARFLAGS	     = cr
RM	     = rm
RMFLAGS      = -rf
TAR          = tar
TARFLAGS     = -cjvf
MAKE        ?= make
INSTALL      = install
CTAGS        = ctags -x > tags
DEPEND       = makedepend $(CFLAGS)

#############################################################################
## lint -- static code mistakes detector
#############################################################################
LINT         = splint
LARCH_PATH   = /usr/local/lib
LCLIMPORTDIR = /usr/local/share/splint/imports

#############################################################################
## dist target file
#############################################################################
DISTTARGET   = .tar.bz2

#############################################################################
## project's source and generated files
#############################################################################
TARGET	     = foobar
SOURCE	     =	main.c \
		foo.c \
		bar.c \
		baz.c

OBJS	     = $(SOURCE:.c=.o)
HEADERS      = $(SOURCE:.c=.h)
TODEL	     = tags *~ .*.swp

#############################################################################
## rules
#############################################################################

all : $(TARGET)

$(TARGET) : $(OBJS)
	$(CC) -o $@ $(OBJS) $(LDFLAGS)

.c.o :
	$(CC) $(CFLAGS) -c $<

lint :
	$(LINT) $(CFLAGS) $(SOURCE)

tags : $(SOURCE)
	$(CTAGS) $(SOURCE)

depend : $(SOURCE)
	$(DEPEND) $(SOURCE)

.PHONY: clean

clean : 
	$(RM) $(RMFLAGS) $(OBJS) $(TODEL)

distclean : clean
	$(RM) $(RMFLAGS) $(TARGET)

dist : distclean
	$(TAR) $(TARFLAGS) $(DISTTARGET) .

check : $(TARGET)
	cd check; $(MAKE) all

install : $(TARGET)
	@echo you must be root to install
\end{lstlisting}

\section{Les limitations}

\section{Ce qu'il ne faut pas faire}
